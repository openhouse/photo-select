import path from "node:path";
import { readFile, writeFile, mkdir, stat, copyFile } from "node:fs/promises";
import { renderTemplate } from "./config.js";
import { listImages, pickRandom, moveFiles } from "./imageSelector.js";
import { chatCompletion, parseReply } from "./chatClient.js";
import { FieldNotesWriter } from "./fieldNotes.js";
<<<<<<< HEAD
<<<<<<< HEAD
import { sha256 } from "./hash.js";
=======
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86

/**
 * Recursively triage images until the current directory is empty
 * or contains only _keep/_aside folders.
 */
export async function triageDirectory({
  dir,
  promptPath,
  model,
  recurse = true,
  curators = [],
  contextPath,
  fieldNotes = false,
<<<<<<< HEAD
<<<<<<< HEAD
  showPrompt,
=======
  showPrompt = false,
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
  showPrompt = false,
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
  depth = 0,
}) {
  const indent = "  ".repeat(depth);
  let context = "";
  if (contextPath) {
    try {
      context = await readFile(contextPath, 'utf8');
    } catch (err) {
      console.warn(`Could not read context file ${contextPath}: ${err.message}`);
    }
  }

  const levelDir = path.join(dir, `_level-${String(depth + 1).padStart(3, '0')}`);
  const initImages = await listImages(dir);
<<<<<<< HEAD
<<<<<<< HEAD
  let levelExists = false;
  try {
    levelExists = (await stat(levelDir)).isDirectory();
  } catch {
    /* ignore */
  }
=======
  const promptsDir = path.join(levelDir, 'prompts');
  const repliesDir = path.join(levelDir, 'replies');
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
  const promptsDir = path.join(levelDir, 'prompts');
  const repliesDir = path.join(levelDir, 'replies');
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
  let notesWriter;
  let fieldNotesText = "";
  if (fieldNotes) {
    notesWriter = new FieldNotesWriter(path.join(levelDir, 'field-notes.md'));
    await notesWriter.init();
    const existing = await notesWriter.read();
    if (existing) fieldNotesText = existing;
  }

  const names = curators.join(', ');
  let prompt = await renderTemplate(promptPath, {
    curators: names,
    context,
    fieldNotes: fieldNotesText,
  });
  let basePrompt = prompt;
  if (fieldNotes) {
    const addonPath = new URL('../prompts/field_notes_addon.txt', import.meta.url).pathname;
    try {
      const addon = await readFile(addonPath, 'utf8');
      prompt += `\n${addon}`;
    } catch (err) {
      console.warn(`Could not read field notes addon: ${err.message}`);
    }
  }

<<<<<<< HEAD
<<<<<<< HEAD
  // Snapshot the prompt to reproduce this batch later.
  // Storing `.prompt.txt` allows us to rerun the exact call.
  await mkdir(levelDir, { recursive: true });
  await writeFile(path.join(levelDir, '.prompt.txt'), prompt, 'utf8');

  if (showPrompt) {
    if (showPrompt === 'hash') {
      console.log(`${indent}üìë  Prompt hash ${sha256(prompt)}`);
    } else if (showPrompt === 'preview') {
      const lines = prompt.split('\n');
      const preview = lines.slice(0, 100).join('\n');
      const truncated = lines.length > 100 ? '\n...<truncated>...' : '';
      console.log(`${indent}üìë  Prompt preview:\n${preview}${truncated}`);
      console.log(`${indent}üìë  Prompt hash ${sha256(prompt)}`);
    } else {
      console.log(`${indent}üìë  Prompt:\n${prompt}`);
    }
=======
  if (showPrompt) {
    console.log(`${indent}üìë  Prompt:\n${prompt}`);
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
  if (showPrompt) {
    console.log(`${indent}üìë  Prompt:\n${prompt}`);
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
  }

  console.log(`${indent}üìÅ  Scanning ${dir}`);

<<<<<<< HEAD
  // Archive original images at this level when directory didn't exist
  if (!levelExists && initImages.length) {
    await Promise.all(
      initImages.map((file) => copyFile(file, path.join(levelDir, path.basename(file))))
=======
  // Archive original images at this level
  try {
    await stat(levelDir);
  } catch {
    // ignore
  }
  await mkdir(levelDir, { recursive: true });
  await mkdir(promptsDir, { recursive: true });
  await mkdir(repliesDir, { recursive: true });
  if (initImages.length) {
    await Promise.all(
      initImages.map((file) =>
        copyFile(file, path.join(levelDir, path.basename(file)))
      )
<<<<<<< HEAD
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
    );
  }

  while (true) {
    const images = await listImages(dir);
    if (images.length === 0) {
      console.log(`${indent}‚úÖ  Nothing to do in ${dir}`);
      break;
    }

    console.log(`${indent}üìä  ${images.length} unclassified image(s) found`);

    // Step 1¬†‚Äì select ‚â§10
    const batch = pickRandom(images, 10);
    console.log(`${indent}üîç  Selected ${batch.length} image(s)`);

    // Step 2¬†‚Äì ask ChatGPT
    console.log(`${indent}‚è≥  Sending batch to ChatGPT‚Ä¶`);
<<<<<<< HEAD
<<<<<<< HEAD
    let reply = await chatCompletion({
=======
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
    const ts = Date.now();
    await writeFile(path.join(promptsDir, `${ts}.prompt.txt`), prompt, 'utf8');
    const reply = await chatCompletion({
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
      prompt,
      images: batch,
      model,
      curators,
    });
    await writeFile(path.join(repliesDir, `${ts}.raw.json`), reply, 'utf8');
    console.log(`${indent}ü§ñ  ChatGPT reply:\n${reply}`);

<<<<<<< HEAD
    let parsed;
    try {
      // Step 3¬†‚Äì parse decisions. Missing field_notes keys break the two-pass workflow.
=======
    // Step 3¬†‚Äì parse decisions
    let parsed;
    try {
<<<<<<< HEAD
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
      parsed = parseReply(reply, batch, {
        expectFieldNotesDiff: fieldNotes,
      });
    } catch (err) {
<<<<<<< HEAD
<<<<<<< HEAD
      if (/field_notes_/.test(err.message)) {
        // Retry once asking the model to regenerate with all keys.
        const retryPrompt = `${prompt}\nPrevious response omitted required keys‚Äîregenerate.`;
        reply = await chatCompletion({
          prompt: retryPrompt,
          images: batch,
          model,
          curators,
        });
        console.log(`${indent}ü§ñ  Retry reply:\n${reply}`);
        parsed = parseReply(reply, batch, {
          expectFieldNotesDiff: fieldNotes,
        });
      } else {
        throw err;
      }
=======
      console.warn(`${indent}Failed to parse reply: ${err.message}`);
      continue;
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
      console.warn(`${indent}Failed to parse reply: ${err.message}`);
      continue;
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
    }
    const { keep, aside, notes, minutes, fieldNotesDiff, fieldNotesMd } = parsed;
    if (minutes.length) {
      const minutesFile = path.join(dir, `minutes-${Date.now()}.txt`);
      await writeFile(minutesFile, minutes.join('\n'), 'utf8');
      console.log(`${indent}üìù  Saved meeting minutes to ${minutesFile}`);
    }

    if (notesWriter && (fieldNotesDiff || fieldNotesMd)) {
      try {
        if (fieldNotesMd) {
          await notesWriter.writeFull(fieldNotesMd);
        } else {
          const existing = (await notesWriter.read()) || '';
          const secondPrompt = await renderTemplate(
            new URL('../prompts/field_notes_second_pass.hbs', import.meta.url).pathname,
            { prompt: basePrompt, existing, diff: fieldNotesDiff }
          );
<<<<<<< HEAD
<<<<<<< HEAD

          // Snapshot second-pass prompt for reproducibility
          await mkdir(levelDir, { recursive: true });
          await writeFile(path.join(levelDir, '.prompt.second.txt'), secondPrompt, 'utf8');

          if (showPrompt) {
            if (showPrompt === 'hash') {
              console.log(`${indent}üìë  Second-pass hash ${sha256(secondPrompt)}`);
            } else if (showPrompt === 'preview') {
              const lines2 = secondPrompt.split('\n');
              const prev = lines2.slice(0, 100).join('\n');
              const trunc = lines2.length > 100 ? '\n...<truncated>...' : '';
              console.log(`${indent}üìë  Second-pass preview:\n${prev}${trunc}`);
              console.log(`${indent}üìë  Second-pass hash ${sha256(secondPrompt)}`);
            } else {
              console.log(`${indent}üìë  Second-pass prompt:\n${secondPrompt}`);
            }
          }
=======
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
          if (showPrompt) {
            console.log(`${indent}üìë  Second-pass prompt:\n${secondPrompt}`);
          }
          await writeFile(path.join(promptsDir, `${ts}-second.prompt.txt`), secondPrompt, 'utf8');
<<<<<<< HEAD
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
          const second = await chatCompletion({
            prompt: secondPrompt,
            images: batch,
            model,
            curators,
          });
<<<<<<< HEAD
<<<<<<< HEAD
          const parsed = parseReply(second, batch, {
            expectFieldNotesMd: true,
          });
=======
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
          await writeFile(path.join(repliesDir, `${ts}-second.raw.json`), second, 'utf8');
          let parsed;
          try {
            parsed = parseReply(second, batch, {
              expectFieldNotesMd: true,
            });
          } catch (err) {
            console.warn(`${indent}Failed to parse second-pass reply: ${err.message}`);
            continue;
          }
<<<<<<< HEAD
>>>>>>> 0890d84fef0310c2fe9bb5c155815202b945b78d
=======
>>>>>>> d094a92de9c6b4b7abda877a9e161037ca186e86
          if (parsed.fieldNotesMd) {
            await notesWriter.writeFull(parsed.fieldNotesMd);
          } else {
            console.warn(`${indent}No field_notes_md returned; diff ignored`);
          }
        }
      } catch (err) {
        console.warn(`${indent}Failed to update field notes: ${err.message}`);
      }
    }

    // Step 4¬†‚Äì move files
    const keepDir = path.join(dir, "_keep");
    const asideDir = path.join(dir, "_aside");
    await Promise.all([
      moveFiles(keep, keepDir, notes),
      moveFiles(aside, asideDir, notes),
    ]);

    console.log(
      `üìÇ  Moved: ${keep.length} keep ‚Üí ${keepDir}, ${aside.length} aside ‚Üí ${asideDir}`
    );
  }

  // Step 5¬†‚Äì recurse into keepDir if both keep and aside exist
  if (recurse) {
    const keepDir = path.join(dir, "_keep");
    const asideDir = path.join(dir, "_aside");
    let keepExists = false;
    try {
      keepExists = (await stat(keepDir)).isDirectory();
    } catch {
      // ignore
    }

    if (keepExists) {
      await triageDirectory({
        dir: keepDir,
        promptPath,
        model,
        recurse,
        curators,
        contextPath,
        fieldNotes,
        depth: depth + 1,
      });
    } else {
      let keepCount = 0;
      let asideCount = 0;
      try {
        keepCount = (await listImages(keepDir)).length;
      } catch {
        // ignore
      }
      try {
        asideCount = (await listImages(asideDir)).length;
      } catch {
        // ignore
      }

      if (keepCount || asideCount) {
        const status = keepCount ? "kept" : "set aside";
        console.log(`${indent}üéØ  All images ${status} at this level; stopping recursion.`);
      }
    }
  }
}
