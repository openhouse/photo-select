import { describe, it, expect } from 'vitest';
import { buildFinalPrompt } from '../../src/core/finalizeCurators.js';

function extractCurators(text) {
  const m = text.match(/(^|\n)\s*-?\s*Curators:\s*(.+)\s*(\n|$)/);
  if (!m) {
    throw new Error(`Curators line missing. Prompt head:\n${text.slice(0, 400)}`);
  }
  return m[2].split(/,\s*/).filter(Boolean);
}

describe('finalizeCurators integration', () => {
<<<<<<< HEAD
  it('appends repeated names in back-to-front order', async () => {
    const cli = ['Kathy Ryan', 'Teju Cole'];
    const photos = [
      { file: 'a.jpg', people: ['Ray Harbin', 'Ellen Lev'] },
      { file: 'b.jpg', people: ['Ray Harbin', 'Mandy Steinback'] },
      { file: 'c.jpg', people: [' Ellen  Lev '] },
      { file: 'd.jpg', people: ['George Markward'] },
    ];
    const { prompt } = await buildFinalPrompt({ cliCurators: cli, photos, images: photos.map((p) => p.file) });
    const names = extractCurators(prompt);
    expect(names).toEqual(['Kathy Ryan', 'Teju Cole', 'Ellen Lev', 'Ray Harbin']);
    expect(names.every((n) => n.trim() === n && n)).toBe(true);
=======
  it('appends repeated names verbatim and orders by last appearance', async () => {
    const cli = ['Beata'];
    const photos = [
      {
        file: 'a.jpg',
        people: ['Beata (Kendell + Mandy cabin neighbor)', 'Ellen Lev'],
      },
      {
        file: 'b.jpg',
        people: ['Beata (Kendell + Mandy cabin neighbor)', 'Ray Harbin'],
      },
      { file: 'c.jpg', people: ['Ellen Lev'] },
    ];
    const { prompt } = await buildFinalPrompt({
      cliCurators: cli,
      photos,
      images: photos.map((p) => p.file),
    });
    const names = extractCurators(prompt);
    expect(names).toEqual([
      'Beata',
      'Ellen Lev',
      'Beata (Kendell + Mandy cabin neighbor)',
    ]);
    expect(prompt).toContain('Identity & aliases (instructions to you):');
>>>>>>> ad4ae9dcb2582761e7001766714a5831c005b5fc
    const header = prompt.split('\n').slice(0, 40).join('\n');
    expect(header).toMatchSnapshot();
  });

<<<<<<< HEAD
  it('falls back to CLI curators when no repeats', async () => {
    const cli = ['Curator A'];
    const photos = [
      { file: 'a.jpg', people: ['Alice'] },
      { file: 'b.jpg', people: ['Bob'] },
    ];
    const { prompt } = await buildFinalPrompt({ cliCurators: cli, photos, images: photos.map((p) => p.file) });
    const names = extractCurators(prompt);
    expect(names).toEqual(['Curator A']);
  });

  it('coalesces hyphen and whitespace variants', async () => {
    const cli = [];
    const photos = [
      { file: 'a.jpg', people: ['Mary - Jane'] },
      { file: 'b.jpg', people: ['Maryâ€‘Jane'] },
    ];
    const { prompt } = await buildFinalPrompt({ cliCurators: cli, photos, images: photos.map((p) => p.file) });
    const names = extractCurators(prompt);
    expect(names).toEqual(['Mary-Jane']);
  });

  it('applies alias map before counting', async () => {
    const cli = [];
    const photos = [
      { file: 'a.jpg', people: ['Ray Harbineued'] },
      { file: 'b.jpg', people: ['Ray Harbin'] },
    ];
    const aliasMap = { 'Ray Harbineued': 'Ray Harbin' };
    const { prompt } = await buildFinalPrompt({ cliCurators: cli, photos, images: photos.map((p) => p.file), aliasMap });
    const names = extractCurators(prompt);
    expect(names).toEqual(['Ray Harbin']);
  });
});
=======
  it('ignores placeholders and falls back to CLI curators when no repeats', async () => {
    const cli = ['Curator A'];
    const photos = [
      { file: 'a.jpg', people: ['_UNKNOWN_', 'Alice'] },
      { file: 'b.jpg', people: ['unknown #2', 'Bob'] },
    ];
    const { prompt } = await buildFinalPrompt({
      cliCurators: cli,
      photos,
      images: photos.map((p) => p.file),
    });
    const names = extractCurators(prompt);
    expect(names).toEqual(['Curator A']);
    expect(prompt).toContain('Identity & aliases (instructions to you):');
  });
});

>>>>>>> ad4ae9dcb2582761e7001766714a5831c005b5fc
